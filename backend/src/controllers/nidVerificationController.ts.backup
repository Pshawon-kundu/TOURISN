import { createHash } from "crypto";
import { Request, Response } from "express";
import { supabase } from "../config/supabase";

interface NIDVerificationRequest {
  userId: string;
  nidNumber: string;
  dateOfBirth: string;
  nidImageBase64?: string;
}

/**
 * Verify Bangladesh NID using OCR and pattern matching
 * For production, integrate with Bangladesh Election Commission API or third-party NID verification service
 */
export const verifyNID = async (req: Request, res: Response) => {
  try {
    const {
      userId,
      nidNumber,
      dateOfBirth,
      nidImageBase64,
    }: NIDVerificationRequest = req.body;

    // Validate required fields
    if (!userId || !nidNumber || !dateOfBirth) {
      return res.status(400).json({
        success: false,
        message: "User ID, NID number, and date of birth are required",
      });
    }

    // Validate NID format (Bangladesh NID: 10, 13, or 17 digits)
    const nidPattern = /^(\d{10}|\d{13}|\d{17})$/;
    if (!nidPattern.test(nidNumber)) {
      return res.status(400).json({
        success: false,
        message: "Invalid NID format. Must be 10, 13, or 17 digits",
      });
    }

    // Validate date of birth format (YYYY-MM-DD)
    const dobPattern = /^\d{4}-\d{2}-\d{2}$/;
    if (!dobPattern.test(dateOfBirth)) {
      return res.status(400).json({
        success: false,
        message: "Invalid date of birth format. Use YYYY-MM-DD",
      });
    }

    let ocrResult: any = null;
    let imageUrl: string | null = null;

    // If image is provided, perform OCR verification
    if (nidImageBase64) {
      try {
        // For demo purposes, simulate OCR extraction
        // In production, use services like:
        // - Google Cloud Vision API
        // - AWS Textract
        // - Azure Computer Vision
        // - Tesseract.js for client-side

        ocrResult = await performOCR(nidImageBase64, nidNumber);

        // Upload image to Supabase Storage
        imageUrl = await uploadNIDImage(userId, nidImageBase64);
      } catch (ocrError) {
        console.error("OCR processing error:", ocrError);
        // Continue with verification even if OCR fails
      }
    }

    // Check if NID is already verified
    const { data: existingVerification } = await supabase
      .from("nid_verifications")
      .select("*")
      .eq("nid_number", nidNumber)
      .eq("status", "verified")
      .single();

    if (existingVerification) {
      return res.status(400).json({
        success: false,
        message: "This NID number is already verified by another user",
      });
    }

    // CRITICAL: Require image for verification
    if (!nidImageBase64) {
      return res.status(400).json({
        success: false,
        message: "NID image is required for verification",
      });
    }

    // Calculate comprehensive verification score
    const verificationScore = calculateVerificationScore(
      nidNumber,
      dateOfBirth,
      ocrResult
    );

    // ULTRA-STRICT: Enhanced security - default to manual review
    let status = "rejected"; // Default to rejected for security
    let statusReason = "";

    // CRITICAL: Without real OCR, all submissions must go through manual review
    if (ocrResult?.requiresManualReview || !ocrResult?.exactMatch) {
      status = "pending_review";
      statusReason = "Manual verification required due to security protocols";
      console.log("ðŸ”’ Forcing manual review due to OCR limitations or NID mismatch");
    } else if (verificationScore >= 90) {
      // Very high confidence - only then auto approve
      status = "verified";
      statusReason = "Automatic verification successful";
    } else if (verificationScore >= 70) {
      // Medium confidence - manual review required
      status = "pending_review"; 
      statusReason = "Manual review required for verification";
    } else if (verificationScore >= 40) {
      // Low confidence - additional verification needed
      status = "pending_additional_info";
      statusReason = "Additional information required for verification";
    } else {
      // Very low confidence - rejected
      status = "rejected";
      statusReason = "Verification failed - invalid or insufficient information";
    }

    // SECURITY: Additional checks for suspicious patterns
    if (await detectSuspiciousActivity(userId, nidNumber, ocrResult)) {
      status = "flagged_for_review";
    }

    // SECURITY: Rate limiting check
    if (await isRateLimited(userId)) {
      return res.status(429).json({
        success: false,
        message: "Too many verification attempts. Please try again later.",
      });
    }

    // Create or update verification record
    const { data: verification, error: verificationError } = await supabase
      .from("nid_verifications")
      .upsert({
        user_id: userId,
        nid_number: nidNumber,
        date_of_birth: dateOfBirth,
        nid_image_url: imageUrl,
        status: status,
        verification_score: verificationScore,
        ocr_data: ocrResult,
        verified_at: status === "verified" ? new Date().toISOString() : null,
      })
      .select()
      .single();

    if (verificationError) {
      throw verificationError;
    }

    // Update user verification status
    if (status === "verified") {
      await supabase
        .from("users")
        .update({
          nid_verified: true,
          verified_at: new Date().toISOString(),
        })
        .eq("id", userId);
    }

    // Log the verification attempt for security monitoring
    await logVerificationAttempt(
      userId,
      nidNumber,
      status,
      verificationScore,
      ocrResult,
      req.ip
    );

    // Prepare response message based on status
    let message = "";
    let nextSteps = "";

    switch (status) {
      case "verified":
        message =
          "ðŸŽ‰ NID verified successfully! You now have full access to all features.";
        nextSteps =
          "You can now apply to become a guide or access premium features.";
        break;
      case "pending_review":
        message =
          "ï¿½ NID verification submitted for manual review due to enhanced security measures. Our team will verify your documents within 24-48 hours.";
        nextSteps =
          "For security, all NID verifications require manual review. You'll receive a notification once complete.";
        break;
      case "pending_additional_info":
        message =
          "ðŸ“ Additional information required for verification.";
        nextSteps =
          "Please ensure your NID image is clear and all information matches your entered details.";
        break;
      case "rejected":
        message =
          "âŒ NID verification failed. Please check your information and try again.";
        nextSteps =
          "Verify that your NID number and date of birth are correct, and upload a clear image of your NID card.";
        break;
      case "flagged_for_review":
        message =
          "âš ï¸ Verification flagged for security review.";
        nextSteps =
          "Our security team will review this submission. Please contact support if you need assistance.";
        break;
      default:
        message = "Verification status unknown. Please contact support.";
    }
        break;
      case "pending_additional_info":
        message =
          "ðŸ“‹ Additional information required. Please upload a clearer image or contact support.";
        nextSteps =
          "Try taking a new photo with better lighting or contact our support team.";
        break;
      case "flagged_for_review":
        message =
          "ðŸ” Your submission requires additional verification for security purposes.";
        nextSteps =
          "Our security team will review your submission. This may take 2-3 business days.";
        break;
      case "rejected":
        message =
          "âŒ NID verification failed. Please check your information and try again.";
        nextSteps =
          "Ensure your NID number matches the card image and try uploading a clearer photo.";
        break;
      default:
        message = "NID submission processed.";
        nextSteps = "Please wait for further instructions.";
    }

    return res.status(200).json({
      success: status !== "rejected",
      message,
      data: {
        verificationId: verification.id,
        status: verification.status,
        score: verificationScore,
        nextSteps,
        requiresManualReview: [
          "pending_review",
          "flagged_for_review",
          "pending_additional_info",
        ].includes(status),
        estimatedReviewTime:
          status === "pending_review"
            ? "24-48 hours"
            : status === "flagged_for_review"
              ? "2-3 business days"
              : null,
        canRetry: status === "rejected" || status === "pending_additional_info",
        securityLevel:
          verificationScore >= 85
            ? "high"
            : verificationScore >= 70
              ? "medium"
              : "low",
      },
    });
  } catch (error: any) {
    console.error("NID verification error:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to verify NID",
      error: error.message,
    });
  }
};

/**
 * Get NID verification status
 */
export const getNIDVerificationStatus = async (req: Request, res: Response) => {
  try {
    const { userId } = req.params;

    const { data: verification, error } = await supabase
      .from("nid_verifications")
      .select("*")
      .eq("user_id", userId)
      .order("created_at", { ascending: false })
      .limit(1)
      .single();

    if (error && error.code !== "PGRST116") {
      // PGRST116 = not found
      throw error;
    }

    return res.status(200).json({
      success: true,
      data: verification || null,
    });
  } catch (error: any) {
    console.error("Get verification status error:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to get verification status",
      error: error.message,
    });
  }
};

/**
 * Advanced OCR extraction and image validation for NID verification
 * Integrates with multiple verification methods for enhanced security
 */
async function performOCR(
  imageBase64: string,
  expectedNID: string
): Promise<any> {
  try {
    // Extract image without data URL prefix
    const base64Data = imageBase64.replace(/^data:image\/\w+;base64,/, "");
    const buffer = Buffer.from(base64Data, "base64");

    // Image validation checks
    const imageValidation = await validateNIDImage(buffer);
    if (!imageValidation.isValid) {
      throw new Error(`Image validation failed: ${imageValidation.reason}`);
    }

    // Use Tesseract.js for OCR (can be replaced with cloud services)
    const ocrResult = await extractTextFromImage(buffer);

    // Enhanced NID pattern matching
    const nidPatterns = [
      /\b(\d{10})\b/g, // 10-digit format
      /\b(\d{13})\b/g, // 13-digit format
      /\b(\d{17})\b/g, // 17-digit format
    ];

    let extractedNIDs: string[] = [];
    for (const pattern of nidPatterns) {
      const matches = ocrResult.text.match(pattern);
      if (matches) {
        extractedNIDs = [...extractedNIDs, ...matches];
      }
    }

    // Additional validation for Bangladesh NID specific features
    const validationFeatures = await validateNIDFeatures(
      buffer,
      ocrResult.text
    );

    // Calculate confidence based on multiple factors
    let confidence = 0;
    let extractedNID = null;
    let isNIDDetected = false;

    if (extractedNIDs.length > 0) {
      isNIDDetected = true;

      // Find the NID that matches expected format
      for (const nid of extractedNIDs) {
        if (nid === expectedNID) {
          extractedNID = nid;
          confidence += 40; // Exact match bonus
          break;
        }
      }

      if (!extractedNID) {
        extractedNID = extractedNIDs[0]; // Take first found NID
        confidence += 20; // Partial match
      }
    }

    // Add confidence based on image quality and features
    confidence += imageValidation.qualityScore;
    confidence += validationFeatures.securityFeatureScore;
    confidence += Math.min(ocrResult.confidence * 30, 30);

    return {
      extractedNID,
      expectedNID,
      allExtractedNIDs: extractedNIDs,
      confidence: Math.min(confidence / 100, 1),
      textBlocks: ocrResult.textBlocks,
      isNIDDetected,
      imageValidation,
      securityFeatures: validationFeatures,
      exactMatch: extractedNID === expectedNID,
      processingTime: Date.now(),
    };
  } catch (error) {
    console.error("OCR processing error:", error);
    throw error;
  }
}

/**
 * Validate NID image for authenticity and quality
 */
async function validateNIDImage(imageBuffer: Buffer): Promise<any> {
  // Basic image validation
  const validation = {
    isValid: true,
    reason: "",
    qualityScore: 0,
    checks: {
      fileSize: false,
      dimensions: false,
      format: false,
      quality: false,
    },
  };

  // Check file size (should be reasonable for a photo)
  const fileSizeKB = imageBuffer.length / 1024;
  if (fileSizeKB < 50 || fileSizeKB > 10240) {
    validation.isValid = false;
    validation.reason = "Invalid file size. Must be between 50KB and 10MB";
    return validation;
  }
  validation.checks.fileSize = true;
  validation.qualityScore += 10;

  // TODO: Add more advanced image validation
  // - Check image dimensions
  // - Detect if it's a real photo vs screenshot
  // - Check for typical NID card features
  // - Validate image metadata

  validation.checks.format = true;
  validation.checks.dimensions = true;
  validation.checks.quality = true;
  validation.qualityScore += 15;

  return validation;
}

/**
 * Extract text from image using OCR (Simplified version)
 */
async function extractTextFromImage(imageBuffer: Buffer): Promise<any> {
  try {
    console.log("Starting enhanced NID validation (without full OCR)...");
    const startTime = Date.now();

    // For now, we'll implement strict validation based on image characteristics
    // In production, replace this with real OCR (Tesseract, Google Vision, etc.)
    
    // Basic image analysis for NID card detection
    const imageAnalysis = await analyzeImageForNID(imageBuffer);
    
    const processingTime = Date.now() - startTime;
    console.log(`Enhanced validation completed in ${processingTime}ms`);

    // Return structured result that requires manual verification for now
    return {
      text: "Enhanced validation: Image uploaded but requires manual verification for security", 
      confidence: 0.3, // Low confidence to trigger manual review
      textBlocks: [],
      processingTime,
      words: [],
      lines: [],
      requiresManualReview: true,
      imageCharacteristics: imageAnalysis,
    };
  } catch (error) {
    console.error("Enhanced validation error:", error);
    throw new Error("Failed to process image for verification");
  }
}

/**
 * Analyze image for basic NID card characteristics
 */
async function analyzeImageForNID(imageBuffer: Buffer): Promise<any> {
  // Basic image analysis without full OCR
  const analysis = {
    hasCardLikeAspectRatio: false,
    hasTextRegions: false,
    sizeAppropriate: false,
    qualityAcceptable: false,
  };

  // Check file size (NID photos are typically 100KB - 5MB)
  const sizeKB = imageBuffer.length / 1024;
  analysis.sizeAppropriate = sizeKB >= 100 && sizeKB <= 5120;
  
  // For now, assume basic validation passes
  analysis.hasCardLikeAspectRatio = true;
  analysis.hasTextRegions = true;
  analysis.qualityAcceptable = sizeKB >= 200; // Minimum quality threshold

  return analysis;
}

/**
 * Validate specific NID security features
 */
async function validateNIDFeatures(
  imageBuffer: Buffer,
  extractedText: string
): Promise<any> {
  // Check for Bangladesh NID specific features
  const features = {
    securityFeatureScore: 0,
    hasSecurityFeatures: false,
    detectedFeatures: {
      logo: false,
      securityElements: false,
      properFormat: false,
      textLayout: false,
    },
  };

  // TODO: Implement actual feature detection
  // - Government logo detection
  // - Security watermark detection
  // - Text layout validation
  // - Font verification

  features.securityFeatureScore = 15; // Mock score
  return features;
}

/**
 * Upload NID image to Supabase Storage
 */
async function uploadNIDImage(
  userId: string,
  imageBase64: string
): Promise<string> {
  try {
    // Remove data URL prefix if present
    const base64Data = imageBase64.replace(/^data:image\/\w+;base64,/, "");
    const buffer = Buffer.from(base64Data, "base64");

    const fileName = `${userId}_${Date.now()}.jpg`;
    const filePath = `nid-images/${fileName}`;

    const { error } = await supabase.storage
      .from("verifications")
      .upload(filePath, buffer, {
        contentType: "image/jpeg",
        upsert: false,
      });

    if (error) {
      throw error;
    }

    // Get public URL
    const { data: urlData } = supabase.storage
      .from("verifications")
      .getPublicUrl(filePath);

    return urlData.publicUrl;
  } catch (error) {
    console.error("Image upload error:", error);
    throw error;
  }
}

/**
 * Calculate comprehensive verification score based on multiple security factors
 */
function calculateVerificationScore(
  nidNumber: string,
  dateOfBirth: string,
  ocrResult: any
): number {
  let score = 0;
  const scoringBreakdown = {
    nidFormat: 0,
    ageValidation: 0,
    ocrMatching: 0,
    imageQuality: 0,
    securityFeatures: 0,
    exactMatch: 0,
    databaseValidation: 0,
  };

  // 1. NID Format Validation (15 points)
  if (/^(\d{10}|\d{13}|\d{17})$/.test(nidNumber)) {
    // Additional validation for Bangladesh NID patterns
    if (isValidBangladeshNIDPattern(nidNumber)) {
      scoringBreakdown.nidFormat = 15;
      score += 15;
    } else {
      scoringBreakdown.nidFormat = 8;
      score += 8;
    }
  }

  // 2. Age and DOB Validation (15 points)
  if (dateOfBirth) {
    const dob = new Date(dateOfBirth);
    const currentDate = new Date();
    let age = currentDate.getFullYear() - dob.getFullYear();

    // Adjust for birthday not yet occurred this year
    const monthDiff = currentDate.getMonth() - dob.getMonth();
    if (
      monthDiff < 0 ||
      (monthDiff === 0 && currentDate.getDate() < dob.getDate())
    ) {
      age--;
    }

    if (age >= 18 && age <= 120) {
      if (age >= 18 && age <= 80) {
        scoringBreakdown.ageValidation = 15; // Normal age range
      } else {
        scoringBreakdown.ageValidation = 10; // Elderly but valid
      }
      score += scoringBreakdown.ageValidation;
    }
  }

  // 3. OCR and Image Analysis (40 points)
  if (ocrResult) {
      // CRITICAL: Force manual review if OCR indicates manual verification needed
      if (ocrResult.requiresManualReview) {
        console.log("ðŸ”’ Manual review required due to OCR limitations");
        scoringBreakdown.ocrMatching = 10; // Low score to trigger manual review
        score += 10;
      } else if (ocrResult.exactMatch && ocrResult.extractedNID === nidNumber) {
        scoringBreakdown.exactMatch = 20;
        score += 20;
      } else if (ocrResult.isNIDDetected) {
        // SECURITY: If NID found but doesn't match, significant penalty
        console.log(`âš ï¸  NID mismatch detected: Expected ${nidNumber}, Found: ${ocrResult.extractedNID}`);
        scoringBreakdown.exactMatch = -10; // Negative score for mismatch
        score -= 10;
      }

      // OCR confidence and quality (10 points)
      const ocrConfidence = ocrResult.confidence || 0;
      if (ocrConfidence >= 0.9) {
        scoringBreakdown.ocrMatching = 10;
        score += 10;
      } else if (ocrConfidence >= 0.7) {
        scoringBreakdown.ocrMatching = 6;
        score += 6;
      } else if (ocrConfidence >= 0.5) {
        scoringBreakdown.ocrMatching = 3;
        score += 3;
      } else {
        // Very low confidence - force manual review
        scoringBreakdown.ocrMatching = 0;
        console.log("ðŸ” Low OCR confidence - manual review recommended");
    // Image quality score (10 points)
    if (ocrResult.imageValidation) {
      scoringBreakdown.imageQuality = Math.min(
        ocrResult.imageValidation.qualityScore,
        10
      );
      score += scoringBreakdown.imageQuality;
    }
  }

  // 4. Security Features Detection (15 points)
  if (ocrResult?.securityFeatures) {
    scoringBreakdown.securityFeatures = Math.min(
      ocrResult.securityFeatures.securityFeatureScore,
      15
    );
    score += scoringBreakdown.securityFeatures;
  }

  // 5. Database Validation (15 points) - TODO: Implement actual database check
  // This would check against Bangladesh Election Commission database
  const databaseValidation = validateAgainstNIDDatabase(nidNumber, dateOfBirth);
  if (databaseValidation.isValid) {
    scoringBreakdown.databaseValidation = 15;
    score += 15;
  }

  console.log("NID Verification Scoring Breakdown:", {
    nidNumber: nidNumber.replace(/.(?=.{4})/g, "*"), // Mask NID for logging
    totalScore: score,
    breakdown: scoringBreakdown,
    timestamp: new Date().toISOString(),
  });

  return Math.min(score, 100);
}

/**
 * Validate Bangladesh NID pattern and check digit
 */
function isValidBangladeshNIDPattern(nidNumber: string): boolean {
  // Bangladesh NID validation rules
  // 10-digit: Old format
  // 13-digit: New format (YYYY + 8 digits)
  // 17-digit: Smart NID format

  if (nidNumber.length === 10) {
    // Old format - basic validation
    return /^[0-9]{10}$/.test(nidNumber);
  }

  if (nidNumber.length === 13) {
    // New format - check birth year
    const birthYear = parseInt(nidNumber.substring(0, 4));
    const currentYear = new Date().getFullYear();
    return birthYear >= 1900 && birthYear <= currentYear;
  }

  if (nidNumber.length === 17) {
    // Smart NID format - more complex validation
    const birthYear = parseInt(nidNumber.substring(0, 4));
    const currentYear = new Date().getFullYear();
    return birthYear >= 1900 && birthYear <= currentYear;
  }

  return false;
}

/**
 * Validate NID against Bangladesh Election Commission database
 * NOTE: This is a placeholder for actual government API integration
 */
function validateAgainstNIDDatabase(
  nidNumber: string,
  dateOfBirth: string
): any {
  // TODO: Integrate with actual Bangladesh Election Commission API
  // For now, implement basic validation rules

  const validation = {
    isValid: false,
    reason: "Database validation not implemented",
    verified: false,
  };

  // Simulate database validation
  // In production, this would:
  // 1. Connect to Bangladesh Election Commission API
  // 2. Verify NID exists and is active
  // 3. Match date of birth
  // 4. Check for any flags or restrictions

  return validation;
}

/**
 * Admin: Manually approve/reject NID verification
 */
/**
 * Detect suspicious verification attempts
 */
async function detectSuspiciousActivity(
  userId: string,
  nidNumber: string,
  ocrResult: any
): Promise<boolean> {
  try {
    // Check for multiple attempts with different NIDs
    const { data: recentAttempts } = await supabase
      .from("nid_verifications")
      .select("nid_number, created_at")
      .eq("user_id", userId)
      .gte(
        "created_at",
        new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()
      ) // Last 24 hours
      .order("created_at", { ascending: false });

    if (recentAttempts && recentAttempts.length > 3) {
      console.warn(
        `Suspicious activity detected: User ${userId} has ${recentAttempts.length} verification attempts in 24h`
      );
      return true;
    }

    // Check if trying different NIDs
    if (recentAttempts && recentAttempts.length > 1) {
      const uniqueNIDs = new Set(
        recentAttempts.map((attempt) => attempt.nid_number)
      );
      if (uniqueNIDs.size > 1) {
        console.warn(
          `Suspicious activity detected: User ${userId} attempted verification with multiple NID numbers`
        );
        return true;
      }
    }

    // Check for common fraud patterns
    if (ocrResult) {
      // Very low OCR confidence might indicate fake/altered document
      if (ocrResult.confidence < 0.3) {
        console.warn(
          `Suspicious activity detected: Very low OCR confidence (${ocrResult.confidence}) for user ${userId}`
        );
        return true;
      }

      // Check if image quality is suspiciously poor (might be screenshot)
      if (
        ocrResult.imageValidation &&
        ocrResult.imageValidation.qualityScore < 5
      ) {
        console.warn(
          `Suspicious activity detected: Poor image quality for user ${userId}`
        );
        return true;
      }
    }

    return false;
  } catch (error) {
    console.error("Error detecting suspicious activity:", error);
    return false; // Don't block on error, but log it
  }
}

/**
 * Check if user is rate limited
 */
async function isRateLimited(userId: string): Promise<boolean> {
  try {
    const { data: recentAttempts } = await supabase
      .from("nid_verifications")
      .select("created_at")
      .eq("user_id", userId)
      .gte("created_at", new Date(Date.now() - 60 * 60 * 1000).toISOString()) // Last hour
      .order("created_at", { ascending: false });

    // Allow max 5 attempts per hour
    return recentAttempts && recentAttempts.length >= 5;
  } catch (error) {
    console.error("Error checking rate limit:", error);
    return false;
  }
}

/**
 * Log verification attempts for security monitoring
 */
async function logVerificationAttempt(
  userId: string,
  nidNumber: string,
  status: string,
  score: number,
  ocrResult: any,
  ipAddress?: string
) {
  try {
    await supabase.from("verification_logs").insert({
      user_id: userId,
      nid_number_hash: hashSensitiveData(nidNumber), // Hash for security
      verification_status: status,
      score: score,
      ip_address: ipAddress,
      ocr_confidence: ocrResult?.confidence,
      suspicious_flags: ocrResult?.suspiciousFlags || [],
      created_at: new Date().toISOString(),
    });
  } catch (error) {
    console.error("Error logging verification attempt:", error);
  }
}

/**
 * Hash sensitive data for logging
 */
function hashSensitiveData(data: string): string {
  return createHash("sha256").update(data).digest("hex");
}

export const updateVerificationStatus = async (req: Request, res: Response) => {
  try {
    const { verificationId } = req.params;
    const { status, notes } = req.body;

    if (!["verified", "rejected"].includes(status)) {
      return res.status(400).json({
        success: false,
        message: "Invalid status. Must be 'verified' or 'rejected'",
      });
    }

    const { data: verification, error } = await supabase
      .from("nid_verifications")
      .update({
        status,
        admin_notes: notes,
        verified_at: status === "verified" ? new Date().toISOString() : null,
      })
      .eq("id", verificationId)
      .select()
      .single();

    if (error) {
      throw error;
    }

    // Update user verification status
    if (status === "verified") {
      await supabase
        .from("users")
        .update({
          nid_verified: true,
          verified_at: new Date().toISOString(),
        })
        .eq("id", verification.user_id);
    }

    return res.status(200).json({
      success: true,
      message: `Verification ${status}`,
      data: verification,
    });
  } catch (error: any) {
    console.error("Update verification status error:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to update verification status",
      error: error.message,
    });
  }
};
